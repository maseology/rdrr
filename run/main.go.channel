package main

import (
	"fmt"
	"math"
	"runtime"

	"rdrr2/lusg"
	"rdrr2/model"

	"github.com/maseology/goHydro/hru"
	mmplt "github.com/maseology/mmPlot"
	"github.com/maseology/mmio"
)

// var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

const mdlPrfx = "M:/Peel/RDRR-PWRMM21/PWRMM21."
const omega = 1.2
const nearzero = 1.e-8

const (
	defaultDepSto    = 0.001  // [m]
	defaultIntSto    = 0.0005 // [m]
	defaultSoilDepth = 0.1    // [m]
	defaultPorosity  = 0.2    // [-]
	defaultFc        = 0.3    // [-]
)

func main() {
	// flag.Parse()
	// if *cpuprofile != "" {
	// 	f, err := os.Create(*cpuprofile)
	// 	if err != nil {
	// 		log.Fatal(err)
	// 	}
	// 	pprof.StartCPUProfile(f)
	// 	defer pprof.StopCPUProfile()
	// }

	fmt.Println("")
	tt := mmio.NewTimer()
	defer tt.Lap(fmt.Sprintf("\nRun complete. n processes: %v", runtime.GOMAXPROCS(0)))

	// load domain
	dom := model.LoadDomain(mdlPrfx)
	nc, ngw := len(dom.Strc.CIDs), len(dom.Mpr.GW)
	fnc := float64(nc)
	tt.Print("Master Domain Load complete")
	dom.Print()

	// initialize hydrological elements with parameter assignment
	lus, xg, xm, dms, fgnc := func() ([]*model.Surface, []int, []int, []float64, []float64) {

		lus := make([]*model.Surface, nc)
		xg, xm := make([]int, nc), make([]int, nc)
		dms, fgnc := make([]float64, ngw), make([]float64, ngw)

		// assign parameters
		for i, c := range dom.Strc.CIDs {
			tanbeta := func() float64 {
				if f, ok := dom.Strc.DwnSlp[c]; ok {
					return f
				}
				panic("fimp load error")
			}()
			tksat := dom.Frc.IntervalSec * func() float64 {
				if isg, ok := dom.Mpr.SGx[c]; ok {
					if k, ok := dom.Mpr.Ksat[isg]; ok {
						return k
					}
				}
				panic("ksat load error")
			}()
			fimp, ifct := func() (float64, float64) {
				if f, ok := dom.Mpr.Fimp[c]; ok {
					if i, ok := dom.Mpr.Ifct[c]; ok {
						return f, i
					}
				}
				panic("fimp load error")
			}()
			fcasc := func() float64 {
				return 1.
			}()
			drel := func() float64 {
				if igw, ok := dom.Mpr.GWx[c]; ok {
					if k, ok := dom.Mpr.GW[igw]; ok {
						if d, ok := k.Drel[c]; ok {
							return d
						}
					}
				}
				panic("drel load error")
			}()
			rzsto, detsto, sma0, det0 := func() (float64, float64, float64, float64) {
				if isw, ok := dom.Mpr.LUx[c]; ok {
					lu := lusg.LandUse{
						DepSto:   defaultDepSto,
						IntSto:   defaultIntSto,
						Porosity: defaultPorosity,
						Fc:       defaultFc,
						Typ:      isw,
					}
					return lu.Rebuild1(defaultSoilDepth, fimp, ifct)
				}
				panic("detsto load error")
			}()

			h := hru.HRU{Sma: hru.Res{Cap: rzsto, Sto: sma0}, Sdet: hru.Res{Cap: detsto, Sto: det0}, Fimp: fimp, Perc: tksat}
			lus[i] = &model.Surface{
				Hru:   h,
				Fcasc: fcasc,
				Drel:  drel,
				Dinc:  0.,
				Bo:    omega * tanbeta * tksat,
				Tm:    1.,
			}

			// cross-referencing
			xg[i] = func() int {
				if ii, ok := dom.Mpr.GWx[c]; ok {
					return ii
				}
				panic("gw xr build error")
			}()
			xm[i] = func() int {
				if ii, ok := dom.Frc.XR[c]; ok {
					return ii
				}
				panic("met xr build error")
			}()
		}

		for i, g := range dom.Mpr.GW {
			fgnc[i] = float64(len(g.CidXR))
			dms[i] = 7.1
		}
		return lus, xg, xm, dms, fgnc
	}()
	tt.Print("HRUs and TOPMODEL build complete")

	// run model
	nstp := len(dom.Frc.T) //800 //
	hyd, ps := make([]float64, nstp), make([]float64, nstp)
	stoL, shyd, sps := 0., 0., 0. // summations
	for _, lu := range lus {
		stoL += lu.Hru.Storage()
	}
	// fmt.Printf("%30s %10s %10s %10s %10s (%6s) %12s\n", "time", "Ya", "aet", "ro", "rch", "delSto", "wbalHRUs")
	for j, t := range dom.Frc.T {
		dmg := make([]float64, len(dms))
		ins := make([]float64, nc)
		saet, sro, srch, sya, sins, sto := 0., 0., 0., 0., 0., 0. // summations
		for i := range dom.Strc.CIDs {
			aet, ro, rch := lus[i].Update(dms[xg[i]], ins[i]+dom.Frc.Ya[xm[i]][j], dom.Frc.Ea[xm[i]][j])
			dmg[xg[i]] -= rch
			ins[dom.Strc.DwnXR[i]] += ro
			// summations
			sto += lus[i].Hru.Storage()
			sya += dom.Frc.Ya[xm[i]][j]
			saet += aet
			sro += ro
			srch += rch
			sins += ins[i]
		}
		hyd[j] = sro / fnc * 1000.
		ps[j] = sya / fnc * 1000.
		shyd += sro / fnc
		sps += sya / fnc
		for i, g := range dmg {
			dms[i] += g / fgnc[i]
		}

		// water balances
		allhruwbal := sya + sins + stoL - (saet + sro + srch + sto)
		if math.Abs(allhruwbal) > nearzero {
			// fmt.Printf("sum{hruwbal} = %e\n", allhruwbal)
			fmt.Print("*")
		}
		if j%120 == 0 {
			// fmt.Printf(" %v %10.1f %10.1f %10.1f %10.1f (%6.2f) %12.8f\n", t, sya*1000, saet*1000, sro*1000, srch*1000, (sto-stoL)*1000, allhruwbal)
			fmt.Printf(" %v %10.4f %10.4f %10.4f %10.4f %10.4f %10.4f %10.4f %10.6f %10.6f\n", t, sya/fnc*1000, saet/fnc*1000, sro/fnc*1000, srch/fnc*1000, dms, shyd/float64(j+1)*365.24*4*1000, sps/float64(j+1)*365.24*4*1000, shyd/sps, allhruwbal)
		}
		stoL = sto

		if j == nstp-1 {
			break
		}
	}

	mmplt.ObsSim("hyd.png", hyd, ps)

	// // connectivity/topology
	// for _, g := range dom.Mpr.GW {
	// 	d := -1.
	// 	ngwcell := len(g.CidXR)

	// 	outs, srcs, snks, mxr := func() (os []<-chan float64, cs []chan float64, ss, mxr []int) {
	// 		os = make([]<-chan float64, ngwcell) // model cell outflow channels
	// 		cs = make([]chan float64, ngwcell)   // model cell source channels, use to impose a forcing
	// 		mxr = make([]int, ngwcell)           // met cellID to slice id cross-reference
	// 		ss = []int{}                         // sinks/roots/outflow
	// 		srcColl := make([][]*<-chan float64, ngwcell)
	// 		xr := make(map[int]int, ngwcell)
	// 		for i, c := range g.CidXR {
	// 			srcColl[i] = []*<-chan float64{}
	// 			xr[c] = i
	// 		}
	// 		for i, c := range g.CidXR { // must be in topological order
	// 			if d, ok := dom.Strc.DwnSlp[c]; ok {
	// 				if d > -1 {
	// 					srcColl[xr[d]] = append(srcColl[xr[d]], &os[i])
	// 				} else {
	// 					ss = append(ss, i)
	// 				}
	// 			} else {
	// 				ss = append(ss, i)
	// 			}
	// 			if len(srcColl[i]) > 0 {
	// 				cs[i] = merge(done, srcColl[i]...)
	// 			} else {
	// 				cs[i] = make(chan float64)
	// 			}
	// 			os[i] = lus[c].SpinUp(done, &d, cs[i], len(srcColl[i])+2)
	// 			mxr[i] = dom.Frc.XR[c]
	// 		}
	// 		return os, cs, ss, mxr
	// 	}()

	// 	outColl := make([]*<-chan float64, len(snks))
	// 	for i, c := range snks {
	// 		outColl[i] = &outs[c]
	// 	}
	// 	mout := merge(done, outColl...)

	// 	nStp := len(dom.Frc.T) // 800 //len(dom.Frc.T)
	// 	tt.Print(fmt.Sprintf("spin-up complete, running %d timesteps..", nStp))
	// 	hyd, ps, es, cc := make([]float64, nStp), make([]float64, nStp), make([]float64, nStp), make([]int, nStp)
	// 	fnGWc := float64(ngwcell)
	// 	// wgen, plast := wgen.WGEN{WetDry: [][]float64{{.85}, {.5}}}, 0.

	// 	go func() {
	// 		for k := 0; k < nStp; k++ { // timesteps
	// 			// // p := 1.
	// 			// p := wgen.Generate(plast) * 1000.
	// 			// plast = p
	// 			yss, ess := 0., 0.
	// 			for i, c := range srcs {
	// 				// fmt.Println(ys[mxr[i]][k], eps[mxr[i]][k])
	// 				c <- dom.Frc.Ya[mxr[i]][k]
	// 				c <- -dom.Frc.Ea[mxr[i]][k]
	// 				// c <- 1.00001
	// 				// c <- -1.
	// 				yss += dom.Frc.Ya[mxr[i]][k]
	// 				ess += dom.Frc.Ea[mxr[i]][k]
	// 				cc[k] += 1
	// 			}
	// 			ps[k] += yss / fnGWc
	// 			es[k] += ess / fnGWc
	// 			// for _, h := range lus {
	// 			// 	sto[k] += h.Hru.Storage()
	// 			// }
	// 			// fmt.Printf("%d of %d :: ", k, nStp)
	// 		}
	// 	}()

	// 	// collect outputs
	// 	for k := 0; k < nStp; k++ { // timesteps
	// 		for range snks {
	// 			hyd[k] = <-mout / fnGWc
	// 			// // if hyd[k] < 0. {
	// 			// hyd[k] = 0.
	// 			// // }
	// 			// // _ = <-mout / fnGWc
	// 			// // hyd[k] += 1
	// 		}
	// 	}

	// 	// cum := 0.
	// 	// for k := 0; k < nStp; k++ {
	// 	// 	cum += ps[k] - es[k]
	// 	// 	fmt.Printf(" %d: %10d %10.4f %10.4f %10.4f %10.4f %10.4f\n", k, cc[k], ps[k], es[k], sto[k], cum, hyd[k])
	// 	// }

	// 	// fmt.Println(hyd)
	// 	mmplt.ObsSim("hyd.png", hyd, ps)
	// 	// break
	// }

	// close(done)
	// time.Sleep(time.Second) // just allows console printing to complete
}

// func merge(done <-chan interface{}, chans ...*<-chan float64) chan float64 {
// 	out := make(chan float64)
// 	go func() {
// 		for _, c := range chans {
// 			select {
// 			case <-done:
// 				return
// 			default:
// 				go func(c <-chan float64) {
// 					for v := range c {
// 						out <- v
// 					}
// 				}(*c)
// 			}
// 		}
// 	}()
// 	return out
// }
