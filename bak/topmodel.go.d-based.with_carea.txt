package gwru

import (
	"math"

	"github.com/maseology/rdrr/tem"
)

// TOPMODEL struct
type TOPMODEL struct {
	ti, di              map[int]float64
	g, dm, qo, m, carea float64
}

// GroundwaterDeficit return cell deficit
func (t *TOPMODEL) GroundwaterDeficit() map[int]float64 {
	return t.di
}

// New constructor
func (t *TOPMODEL) New(ksat map[int]float64, topo tem.TEM, cw, q0, qo, m float64) {
	// q0: initial catchment flow rate [m³/s]
	t.m = 1.0                     // parameter m
	n := float64(topo.NumCells()) // number of cells
	t.carea = cw * cw * n         // cw: cellwidth [m]
	t.qo = qo                     // qo: baseflow when basin is fully saturated [m3/s]

	t.g = 0.                     // gamma
	t.ti = make(map[int]float64) // soil-topographic index
	t.di = make(map[int]float64) // depth to watertable
	for i, v := range topo.TECs {
		t0 := ksat[i] * cw                      // lateral transmisivity when soil is saturated [m²/s]
		ai := topo.UnitContributingArea(i) * cw // contributing area per unit contour [m]
		t.ti[i] = math.Log(ai / t0 / math.Tan(v.S))
		t.g += cw * cw * t.ti[i]
	}
	t.g /= t.carea
	t.dm = -t.m * math.Log(q0/qo) // initialize basin-wide deficit and cell deficits
	for i := range topo.TECs {
		t.di[i] = t.dm + t.m*(t.g-t.ti[i])
	}
}

// Update state. input g: total basin average recharge per time step [m]
func (t *TOPMODEL) Update(g float64) float64 {
	// returns baseflow
	t.dm = -g
	for _, v := range t.di {
		t.dm += v
	}

	qb := t.qo * math.Exp(-t.dm/t.m)
	t.dm += qb

	// update cell deficits
	for i := range t.di {
		t.di[i] = t.dm + t.m*(t.g-t.ti[i])
	}
	return qb
}
