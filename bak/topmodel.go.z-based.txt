package gwru

import (
	"math"

	"github.com/maseology/rdrr/tem"
)

// TOPMODEL struct
type TOPMODEL struct {
	ti, zi                 map[int]float64
	g, zm, carea, f, nstrm float64
}

// DepthToWatertable return cell-approximated depth to watertable [m]
func (m *TOPMODEL) DepthToWatertable() map[int]float64 {
	return m.zi
}

// New constructor
func (m *TOPMODEL) New(ksat map[int]float64, topo tem.TEM, cw, q0 float64) {
	// q0: initial catchment flow rate [m³/s]
	m.f = 1.0                     // parameter f
	m.nstrm = 0.1                 // average drainable porosity along stream reaches
	n := float64(topo.NumCells()) // number of cells
	m.carea = cw * cw * n         // cw: cellwidth [m]

	m.g = 0.                     // gamma
	m.ti = make(map[int]float64) // topographic index
	m.zi = make(map[int]float64) // depth to watertable
	for i, v := range topo.TECs {
		t0 := ksat[i] * cw                      // downslope transmisivity when soil is saturated [m²/s]
		ai := topo.UnitContributingArea(i) * cw // contributing area per unit contour [m]
		m.ti[i] = math.Log(ai / t0 / math.Tan(v.S))
		m.g += m.ti[i]
	}
	m.g /= m.carea
	m.zm = -math.Log10(q0/(m.carea*n)/m.nstrm/math.Exp(-m.g)) / m.f // initialize mean depth to watertable and relative depths to watertable
	for i := range topo.TECs {
		m.zi[i] = m.zm + (m.g-m.ti[i])/m.f
	}
}

// Update state. g: recharge [m/s]
func (m *TOPMODEL) Update(g map[int]float64) float64 {
	// returns baseflow
	n := float64(len(g)) // number of cells
	var qv float64
	for _, v := range g {
		qv += v
	}
	qv *= m.carea                                             // catchment recharge [m³/s]
	qb := m.carea * n * m.nstrm * math.Exp(-(m.g + m.f*m.zm)) // baseflow discharge [m³/s]
	m.zm += qb - qv

	for i := range g {
		m.zi[i] = m.zm + (m.g-m.ti[i])/m.f
	}
	return qb
}
